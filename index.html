<!DOCTYPE html>
<html>

<head>
    <link rel="shortcut icon" href="#">
    <title>Audio Engine Prototype</title>
</head>

<body>
    <button id="startBtn" onclick="startAudio()">Start</button>
    <button id="stopBtn" onclick="stopAudio()">Stop</button>
    <div>
        <section>
            <h4 style="margin-bottom: 5px; color: #888">Number of Tracks</h4>
            <button id="1-button" onclick="changeNumTracks(1)">1</button>
            <button id="2-button" onclick="changeNumTracks(2)">2</button>
            <button id="9-button" onclick="changeNumTracks(9)">9</button>
            <button id="10-button" onclick="changeNumTracks(10)">10</button>
            <button id="100-button" onclick="changeNumTracks(100)">100</button>
            <button id="250-button" onclick="changeNumTracks(250)">250</button>
            <button id="1000-button" onclick="changeNumTracks(1000)">1000</button>
            <button id="band-button" onclick="loadTrackConfig('config.json')">Band</button>
            <button id="debug-button" onclick="debug()">Debug</button>
        </section>
        <script>
            exports = {};
        </script>
        <script src="utils.js"></script>
        <script src="index.js"></script>
        <script src="audiostore.js"></script>
        <script>
            const audioContext = new AudioContext();
            audioContext.suspend();
            console.log("audioContext.sampleRate: ", audioContext.sampleRate);

            const store = new AudioStore(audioContext);
            store.init();

            let decodedFileNames = [];
            document.getElementById("startBtn").disabled = true;

            let worker = null;
        
            function setupAudioReader(sab, trackModel) {
                URLFromFiles(['audioreader.js', 'index.js', 'audiostore.js']).then((e) => {
                    worker = new Worker(e);

                    URLFromFiles(["audioreaderworker.js", "index.js", "audiostore.js"]).then((url) => {
                        worker.postMessage({
                            command: "init",
                            sab: sab,
                            trackModel: trackModel,
                            workerURL: url
                        });
                    })

                    worker.onmessage = e => {
                        console.log("ready");
                        switch (e.data.command) {
                            case "ready": {
                                document.getElementById("startBtn").disabled = false;
                                break;
                            }
                            default: {
                                throw Error("Unknown case in app.js");
                            }
                        }
                    }
                });
            }

            function setupAudioRoutingGraph(trackModel) {
                URLFromFiles(["processor.js", "index.js"]).then((e) => {
                    if (audioContext.audioWorklet === undefined) {
                        log("No AudioWorklet.");
                    } else {
                        audioContext.audioWorklet.addModule(e).then(() => {
                            const tracks = trackModel.tracks;
                            const numberOfOutputs = tracks.length;
                            // 50ms of buffer, increase in case of glitches
                            const sab = exports.RingBuffer.getStorageForCapacity(
                                (audioContext.sampleRate / 20) * numberOfOutputs,
                                Float32Array
                            );

                            async function loadAudioFiles() {
                                let promises = [];
                                for (var iTrack = 0; iTrack < numberOfOutputs; iTrack++) {
                                    const track = tracks[iTrack];
                                    const numClips = track.clips.length;
                                    for (var iClip = 0; iClip < numClips; iClip++) {
                                        const clip = track.clips[iClip];
                                        promises.push(loadAudioFile(clip));
                                    }
                                }

                                await Promise.all(promises);
                            }

                            loadAudioFiles().then(() => {
                                console.log("setup reader");
                                setupAudioReader(sab, trackModel);
                            });

                            const audioWorkletNode = new AudioWorkletNode(audioContext, "processor", {
                                processorOptions: {
                                    audioQueue: sab,
                                },
                                numberOfOutputs: numberOfOutputs
                            });

                            for (let iOutput = 0; iOutput < numberOfOutputs; iOutput++) {
                                let gain = audioContext.createGain();
                                gain.gain.value = 1/numberOfOutputs;
                                audioWorkletNode.connect(gain, iOutput);
                                gain.connect(audioContext.destination);
                            }

                            // navigator.mediaDevices.getUserMedia({
                            //     audio: {
                            //         // echoCancellation: false,
                            //         autoGainControl: false,
                            //         noiseSuppression: false,
                            //         latency: 0
                            //     }
                            // }).then(userMedia => {
                            //     const input = audioContext.createMediaStreamSource(userMedia);
                            //     input.connect(audioWorkletNode);
                            // }
                            // )
                        });
                    }
                });
            }

            async function loadAudioFile(clip) {
                return new Promise((resolve, reject) => {
                    if (decodedFileNames.includes(clip.fileName)) {
                        resolve();
                    } else {
                        var request = new XMLHttpRequest();
                        request.open('GET', clip.fileName, true);
                        request.responseType = 'arraybuffer';
                        request.onload = () => {
                            var audioData = request.response;
                            console.log("decodeAudioData ", clip.fileName);
                            audioContext.decodeAudioData(audioData, function (buffer) {
                                store.saveAudioBuffer(clip.fileName, buffer).then(metadata => {
                                    duration = metadata.duration;
                                    resolve();
                                });
                            },

                                e => {
                                    console.log("Error with decoding audio data" + e.err);
                                    reject()
                                });
                        }

                        request.onerror = reject;
                        request.send();

                        decodedFileNames.push(clip.fileName);
                    }

                });
            }

            function loadTrackConfig(configFileName) {
                const request = new XMLHttpRequest();
                request.open("GET", configFileName);
                request.onload = function () {
                    const trackModel = JSON.parse(request.responseText);
                    setupAudioRoutingGraph(trackModel);
                }
    
                request.send();
            }

            function startAudio() {
                audioContext.resume();
            }

            function stopAudio() {
                audioContext.suspend();
            }

            function createTrackConfig(nTracks) {
                let trackConfig = {};
                trackConfig.tracks = [];

                let samplePos = 0;
                let length = 1323000;
                let iStartInFile = 0;
                let iEndInFile = 1323000;
                for (let iTrack = 0; iTrack < nTracks; iTrack++) {
                    let track = {};

                    track.id = iTrack;
                    track.number = iTrack + 1;
                    track.lastClipIndex = 0;
                    track.clips = [];

                    let clip = {};
                    clip.fileName = "audio/sweep.wav";
                    clip.samplePos = samplePos;
                    clip.length = length;
                    clip.iStartInFile = iStartInFile;
                    clip.iEndInFile = iEndInFile;

                    track.clips.push(clip);
                    trackConfig.tracks.push(track);
                }

                return trackConfig;
            }

            function changeNumTracks(nTracks) {
                const trackModel = createTrackConfig(nTracks);
                setupAudioRoutingGraph(trackModel);
            }

            function debug() {
                worker.postMessage({command: "preload debug"});
            }
        </script>
</body>

</html>