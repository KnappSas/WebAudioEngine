<!DOCTYPE html>
<html>

<head>
    <link rel="shortcut icon" href="#">
    <title>Audio Engine Prototype</title>
</head>

<body>
    <button id="startBtn" onclick="startAudio()">Start</button>
    <button id="stopBtn" onclick="stopAudio()">Stop</button>
    <div>
        <section>
            <h4 style="margin-bottom: 5px; color: #888">Number of Tracks</h4>
            <p style="font-size: 0.7em; color: #999">Select either the number of tracks that are created for streaming a
                test signal from IndexedDB
                or select 'Band' to playback actual stems from a band.
                </a></p>
            <button id="track-1" onclick="changeNumTracks(1)">1</button>
            <button id="track-2" onclick="changeNumTracks(2)">2</button>
            <button id="track-9" onclick="changeNumTracks(9)">9</button>
            <button id="track-10" onclick="changeNumTracks(10)">10</button>
            <button id="track-100" onclick="changeNumTracks(100)">100</button>
            <button id="track-250" onclick="changeNumTracks(250)">250</button>
            <button id="track-1000" onclick="changeNumTracks(1000)">1000</button>
            <button id="track-band" onclick="loadTrackConfig('config.json')">Band</button>
            <!-- <button id="debug" onclick="debug()">Debug</button> -->
        </section>
        <section>
            <h4 style="margin-bottom: 5px; color: #888">Audio processing language</h4>
            <p style="font-size: 0.7em; color: #999">Select which language is used
                for the load generation.
                </a></p>
            <div>
                <input type="radio" id="choice-js" name="lang" value="js" onchange="changeProcessingLanguage('js')" />
                <label style="font-size: 0.8em;" for="choice-js">JavaScript</label>
            </div>
            <div>
                <input type="radio" id="choice-wasm" name="lang" value="wasm"
                    onchange="changeProcessingLanguage('wasm')" />
                <label style="font-size: 0.8em;" for="choice-wasm">WebAssembly (faster)</label>
            </div>
        </section>
        <section>
            <h4 style="margin-bottom: 5px; color: #888">Parameters</h4>
            <p style="font-size: 0.7em; color: #999">...</a></p>
            <div style="display: flex;flex-flow: row;align-items: center;">
                <input type="range" id="load-slider" min="0" max="50" step="1.0" value="1"
                    onchange="changeProcessingLoad()" />
                <label id="load-slider-label" style="font-size: 0.8em;text-align: center;" for="load-slider"></label>
            </div>
            <h4 style="margin-bottom: 5px; color: #888">Presets</h4>
            <p style="font-size: 0.7em; color: #999">...</a></p>
            <div>
                <button id="load-0" onclick="changeProcessingLoad(0)">0</button>
                <button id="load-1" onclick="changeProcessingLoad(1)">1</button>
                <button id="load-10" onclick="changeProcessingLoad(10)">10</button>
                <button id="load-25" onclick="changeProcessingLoad(25)">25</button>
                <button id="load-50" onclick="changeProcessingLoad(50)">50</button>
            </div>
        </section>
        <script>
            exports = {};
        </script>
        <script src="utils.js"></script>
        <script src="index.js"></script>
        <script src="audiostore.js"></script>
        <script>
            const audioContext = new AudioContext();
            audioContext.suspend();
            console.log("audioContext.sampleRate: ", audioContext.sampleRate);

            const store = new AudioStore(audioContext);
            store.init();

            let decodedFileNames = [];
            document.getElementById("startBtn").disabled = true;

            let worker = null;
            let loadGenerator = null;

            function setupAudioReader(sab, trackModel) {
                URLFromFiles(['audioreader.js', 'index.js', 'audiostore.js']).then((e) => {
                    worker = new Worker(e);

                    URLFromFiles(["audioreaderworker.js", "index.js", "audiostore.js"]).then((url) => {
                        worker.postMessage({
                            command: "init",
                            sab: sab,
                            trackModel: trackModel,
                            workerURL: url
                        });
                    })

                    worker.onmessage = e => {
                        console.log("ready");
                        switch (e.data.command) {
                            case "ready": {
                                document.getElementById("startBtn").disabled = false;
                                break;
                            }
                            default: {
                                throw Error("Unknown case in app.js");
                            }
                        }
                    }
                });
            }

            async function createLoadGeneratorNode(input, iOutput, output) {
                const processorPath = window.language === "js" ? "load-processor.js" : "load-processor-wasm.js";
                const processorName = window.language === "js" ? "load-processor-js" : "load-processor-wasm";

                await audioContext.audioWorklet.addModule(processorPath);

                audioWorkletNode = new AudioWorkletNode(audioContext, processorName);
                audioWorkletNode.port.onmessage = (event) => onmessage(event.data);
                audioWorkletNode.connect(audioContext.destination);

                if (window.language === "wasm") {
                    fetch("load-wasm/target/wasm32-unknown-unknown/release/load_wasm.wasm")
                        .then(r => r.arrayBuffer())
                        .then(r => audioWorkletNode.port.postMessage({ type: 'load-wasm-module', data: r }));
                }

                input
                    .connect(audioWorkletNode, iOutput)
                    .connect(output);

                return audioWorkletNode;
            }

            async function setupAudioRoutingGraph(trackModel) {
                URLFromFiles(["wave-processor.js", "index.js"]).then(async (e) => {
                    if (audioContext.audioWorklet === undefined) {
                        log("No AudioWorklet.");
                    } else {
                        await audioContext.audioWorklet.addModule(e);

                        const tracks = trackModel.tracks;
                        const numberOfOutputs = tracks.length;
                        // 50ms of buffer, increase in case of glitches
                        const sab = exports.RingBuffer.getStorageForCapacity(
                            (audioContext.sampleRate / 20) * numberOfOutputs,
                            Float32Array
                        );

                        async function loadAudioFiles() {
                            let promises = [];
                            for (var iTrack = 0; iTrack < numberOfOutputs; iTrack++) {
                                const track = tracks[iTrack];
                                const numClips = track.clips.length;
                                for (var iClip = 0; iClip < numClips; iClip++) {
                                    const clip = track.clips[iClip];
                                    promises.push(loadAudioFile(clip));
                                }
                            }

                            await Promise.all(promises);
                        }

                        loadAudioFiles().then(() => {
                            console.log("setup reader");
                            setupAudioReader(sab, trackModel);
                        });

                        const audioWorkletNode = new AudioWorkletNode(audioContext, "wave-processor", {
                            processorOptions: {
                                audioQueue: sab,
                            },
                            numberOfOutputs: numberOfOutputs
                        });

                        let masterGain = audioContext.createGain();
                        for (let iOutput = 0; iOutput < numberOfOutputs; iOutput++) {
                            let gain = audioContext.createGain();
                            gain.gain.value = 1 / numberOfOutputs;
                            audioWorkletNode.connect(gain, iOutput);
                            gain.connect(masterGain);
                        }

                        loadGenerator = await createLoadGeneratorNode(masterGain, 0, audioContext.destination);
                        let loadParam = loadGenerator.parameters.get("load");
                        loadParam.value = 10;
                        // navigator.mediaDevices.getUserMedia({
                        //     audio: {
                        //         // echoCancellation: false,
                        //         autoGainControl: false,
                        //         noiseSuppression: false,
                        //         latency: 0
                        //     }
                        // }).then(userMedia => {
                        //     const input = audioContext.createMediaStreamSource(userMedia);
                        //     input.connect(audioWorkletNode);
                        // }
                        // )
                    }
                });
            }

            async function loadAudioFile(clip) {
                return new Promise((resolve, reject) => {
                    if (decodedFileNames.includes(clip.fileName)) {
                        resolve();
                    } else {
                        var request = new XMLHttpRequest();
                        request.open('GET', clip.fileName, true);
                        request.responseType = 'arraybuffer';
                        request.onload = () => {
                            var audioData = request.response;
                            console.log("decodeAudioData ", clip.fileName);
                            audioContext.decodeAudioData(audioData, function (buffer) {
                                store.saveAudioBuffer(clip.fileName, buffer).then(metadata => {
                                    duration = metadata.duration;
                                    resolve();
                                });
                            },

                                e => {
                                    console.log("Error with decoding audio data" + e.err);
                                    reject()
                                });
                        }

                        request.onerror = reject;
                        request.send();

                        decodedFileNames.push(clip.fileName);
                    }

                });
            }

            function loadTrackConfig(configFileName) {
                const request = new XMLHttpRequest();
                request.open("GET", configFileName);
                request.onload = function () {
                    const trackModel = JSON.parse(request.responseText);
                    setupAudioRoutingGraph(trackModel);
                }

                request.send();
            }

            function startAudio() {
                audioContext.resume();
            }

            function stopAudio() {
                audioContext.suspend();
            }

            function createTrackConfig(nTracks) {
                let trackConfig = {};
                trackConfig.tracks = [];

                let samplePos = 0;
                let length = 1323000;
                let iStartInFile = 0;
                let iEndInFile = 1323000;
                for (let iTrack = 0; iTrack < nTracks; iTrack++) {
                    let track = {};

                    track.id = iTrack;
                    track.number = iTrack + 1;
                    track.lastClipIndex = 0;
                    track.clips = [];

                    let clip = {};
                    clip.fileName = "audio/sweep.wav";
                    clip.samplePos = samplePos;
                    clip.length = length;
                    clip.iStartInFile = iStartInFile;
                    clip.iEndInFile = iEndInFile;

                    track.clips.push(clip);
                    trackConfig.tracks.push(track);
                }

                return trackConfig;
            }

            function changeNumTracks(nTracks) {
                const trackModel = createTrackConfig(nTracks);
                setupAudioRoutingGraph(trackModel);
            }

            function changeProcessingLanguage(language) {
                window.language = language;
                const newUrl = `${window.location.origin}${window.location.pathname}?strings=${window.numStrings}&visualize=${window.visualize}&channel=${window.channel}&ratio=${window.ratio}&lang=${window.language}`;
                window.location.href = newUrl;
            }

            function changeProcessingLoad(newLoad = -1) {
                if (newLoad < 0) {
                    console.log("changeProcessingLoad")
                    let load = 0;
                    if (loadGenerator) {
                        let loadParam = loadGenerator.parameters.get("load");
                        load = document.getElementById("load-slider").value;
                        loadParam.value = load < 1 ? 0.001 : Math.floor(load);
                    }

                    document.getElementById("load-slider-label").innerHTML = `Load: ${load}`;
                } else {
                    // in this case changeProcessingLoad was set with an explicit value
                    document.getElementById("load-slider").value = newLoad;
                    changeProcessingLoad();
                }
            }

            function debug() {
                worker.postMessage({ command: "preload debug" });
            }

            const urlParams = new URLSearchParams(window.location.search);
            const lang = urlParams.get('lang') === "js"
                ? "js"
                : "wasm"

            window.language = lang;
            switch (lang) {
                case "wasm": document.getElementById("choice-wasm").checked = true; break;
                case "js": document.getElementById("choice-js").checked = true; break;
            }

            document.getElementById("load-slider-label").innerHTML = "Load: 0";
        </script>
</body>

</html>